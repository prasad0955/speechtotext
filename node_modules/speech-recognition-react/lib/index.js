"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSpeechRecognition = void 0;
const react_1 = require("react");
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
const SpeechGrammarList = window.SpeechGrammarList || window.webkitSpeechGrammarList;
const useSpeechRecognition = (options) => {
    const [_options, setOptions] = (0, react_1.useState)({
        continuous: true,
        grammar: '#JSGF V1.0; grammar word; public <word> = hello world ;',
        interimResults: true,
        lang: 'en-US',
        maxAlternatives: 1,
        regex: new RegExp('hello world', 'gi'),
        startOnLoad: true,
        onaudioend: null,
        onaudiostart: null,
        onend: null,
        onerror: null,
        onnomatch: null,
        onresult: null,
        onsoundend: null,
        onsoundstart: null,
        onspeechend: null,
        onspeechstart: null,
        onstart: null,
        ...options,
    });
    const [transcripts, setTranscripts] = (0, react_1.useState)([]);
    const [liveTranscript, setLiveTranscript] = (0, react_1.useState)('');
    const [match, setMatch] = (0, react_1.useState)(null);
    const recognition = (0, react_1.useRef)(new SpeechRecognition());
    const isInitialized = (0, react_1.useRef)(false);
    const isListening = (0, react_1.useRef)(false);
    const handleResult = (0, react_1.useCallback)((event) => {
        const result = event.results.item(event.resultIndex);
        const confidence = result[0].confidence;
        const isFinal = result.isFinal;
        const _transcript = result[0].transcript;
        if (result.isFinal) {
            setTranscripts(prev => {
                const id = (Math.random() * 1000000000000).toString(16).split('.')[0];
                prev.push({ id, confidence, isFinal, transcript: _transcript });
                return [...prev];
            });
            setLiveTranscript('');
        }
        else {
            setLiveTranscript(result[0].transcript);
        }
        const matchedColor = ([..._transcript.matchAll(_options.regex)].pop()?.[0] || '').toLowerCase();
        if (_options.regex.test(matchedColor)) {
            setMatch(matchedColor);
        }
        else {
            setMatch(null);
        }
        if (_options.onresult)
            _options.onresult(event);
    }, [_options]);
    const handleStart = (0, react_1.useCallback)((event) => {
        if (_options.onend)
            _options.onend(event);
        isListening.current = true;
    }, [_options]);
    const handleEnd = (0, react_1.useCallback)((event) => {
        recognition.current.stop();
        if (_options.continuous)
            setTimeout(() => recognition.current.start(), 0);
        if (_options.onend)
            _options.onend(event);
        isListening.current = false;
    }, [_options]);
    const start = (0, react_1.useCallback)((startOptions) => {
        if (startOptions)
            setOptions(prev => ({
                ...prev,
                ...startOptions,
            }));
        if (isListening.current)
            return;
        recognition.current.start();
    }, []);
    const restart = (0, react_1.useCallback)((startOptions) => {
        recognition.current.stop();
        setTimeout(() => start(startOptions), 0);
    }, [start]);
    const abort = (0, react_1.useCallback)(() => recognition.current.abort(), []);
    const stop = (0, react_1.useCallback)(() => recognition.current.stop(), []);
    const initializeSpeechRecognition = (0, react_1.useCallback)(() => {
        const speechRecognitionList = new SpeechGrammarList();
        speechRecognitionList.addFromString(_options.grammar, 1);
        recognition.current.grammars = speechRecognitionList;
        recognition.current.continuous = _options.continuous;
        recognition.current.interimResults = _options.interimResults;
        recognition.current.lang = _options.lang;
        recognition.current.maxAlternatives = _options.maxAlternatives;
        const callback = (event, func) => {
            if (func)
                func(event);
        };
        recognition.current.onaudioend = e => callback(e, _options.onaudioend);
        recognition.current.onaudiostart = e => callback(e, _options.onaudiostart);
        recognition.current.onend = handleEnd;
        recognition.current.onerror = _options.onerror;
        recognition.current.onnomatch = _options.onnomatch;
        recognition.current.onresult = handleResult;
        recognition.current.onsoundend = e => callback(e, _options.onsoundend);
        recognition.current.onsoundstart = e => callback(e, _options.onsoundstart);
        recognition.current.onspeechend = e => callback(e, _options.onspeechend);
        recognition.current.onspeechstart = e => callback(e, _options.onspeechstart);
        recognition.current.onstart = handleStart;
        isInitialized.current = true;
        if (_options.startOnLoad)
            recognition.current.start();
    }, [
        _options.continuous,
        _options.grammar,
        _options.interimResults,
        _options.lang,
        _options.maxAlternatives,
        _options.onaudioend,
        _options.onaudiostart,
        _options.onerror,
        _options.onnomatch,
        _options.onsoundend,
        _options.onsoundstart,
        _options.onspeechend,
        _options.onspeechstart,
        _options.startOnLoad,
        handleEnd,
        handleResult,
        handleStart,
    ]);
    (0, react_1.useEffect)(() => {
        if (!isInitialized.current)
            initializeSpeechRecognition();
    }, [initializeSpeechRecognition]);
    return (0, react_1.useMemo)(() => ({
        liveTranscript,
        match,
        restart,
        start,
        transcripts,
        abort,
        stop,
        instance: recognition.current,
    }), [liveTranscript, match, restart, start, transcripts]);
};
exports.useSpeechRecognition = useSpeechRecognition;
